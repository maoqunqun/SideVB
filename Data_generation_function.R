## SideVB synthetic data generation
##
## This file contains lightweight utilities to generate synthetic regression data
## with side information (feature-level covariates) for simulation studies.
##
## Design overview:
## - X: sample-by-feature design matrix (n x p)
## - Z: feature-by-covariate side information matrix (p x q), including an intercept
## - beta: sparse true coefficients (length p)
## - Y: response vector (length n)
##
## Dependencies: base R only.

#' Generalized logistic function
#'
#' @description
#' A flexible logistic link used to convert a linear predictor to probabilities.
#' This is the standard logistic when `k = 1`, `c = 0`, and `v = 1`.
#'
#' @param x Numeric vector.
#' @param k Numeric. Steepness.
#' @param c Numeric. Location (midpoint).
#' @param v Numeric. Shape.
#'
#' @return Numeric vector of values in $(0, 1)$.
#' @keywords internal
generalized_logistic <- function(x, k = 1, c = 0, v = 1) {
  1 / (1 + exp(-k * (x - c)))^v
}

.as_numeric_vector <- function(x) {
  # Avoid magrittr/dplyr dependencies.
  as.vector(x)
}

.require_L_for_correlated <- function(L, cov_matrix) {
  if (!is.null(L)) {
    return(L)
  }
  if (!is.null(cov_matrix)) {
    # chol() returns an upper-triangular factor U such that t(U) %*% U = cov_matrix.
    return(t(chol(cov_matrix)))
  }
  stop("For re_sd = 'Matern' or 'Identical', please provide either L or cov_matrix.")
}

# ------------------------------------------------------------------------------


#' Generate synthetic regression data with side information
#'
#' @description
#' Creates a standardized design matrix `X` (n x p), feature-level side information `Z`
#' (p x q, including an intercept), sparse true coefficients `true_beta`, and the
#' response vector `Y` at a target signal-to-noise ratio.
#'
#' The sparsity pattern of `true_beta` is generated by:
#' 1) computing a linear predictor $\eta_j = Z_j^\top \theta$ for each feature $j$;
#' 2) mapping $\eta$ to probabilities via a generalized logistic link;
#' 3) sampling inclusion indicators `selection ~ Bernoulli(s_prob)`.
#'
#' @param n Integer. Number of samples.
#' @param p Integer. Number of features.
#' @param re_sd Character. How to generate dependence (legacy behavior):
#'   - `"Independent"`: X is i.i.d. normal; Z is i.i.d. (binary or continuous).
#'   - `"Matern"`: X is correlated across features using `L`; Z is generated from
#'     **two** correlated columns (so typically `q = 3`, intercept + 2 side columns).
#'     This matches the original simulation code.
#'   - `"Identical"`: X is correlated using `L`; Z is still generated i.i.d. from
#'     `z_mean` (binary) or left as generated (legacy).
#' @param L Matrix or `NULL`. Lower-triangular Cholesky factor for a p x p covariance
#'   matrix over features. If `NULL` and `cov_matrix` is provided, `L` is computed.
#' @param cov_matrix Matrix or `NULL`. p x p covariance matrix over features.
#' @param q Integer. Number of columns in `Z` including intercept. `q >= 1`.
#' @param mu_beta_true Numeric. Controls the magnitude of non-zero coefficients.
#' @param theta_intercept Numeric. Intercept in the side-information model.
#' @param theta_side_info Numeric. Coefficient for each side-information column.
#' @param SNR Numeric > 0. Signal-to-noise ratio used to set the noise standard deviation.
#' @param z_mean Numeric. Mean/probability used to generate i.i.d. side information.
#'   If `binary_Z = TRUE`, this is the Bernoulli probability.
#' @param z_variance Numeric > 0. Variance used to generate i.i.d. continuous side information.
#' @param seed_val Integer or `NULL`. If provided, sets the random seed.
#' @param binary_Z Logical. If `TRUE`, side information is binary {0,1}.
#' @param k,c,v Numeric. Parameters for `generalized_logistic()`.
#' @param verbose Logical. If `TRUE`, prints brief diagnostics.
#' @param return_diagnostics Logical. If `TRUE`, includes a confusion table and other
#'   diagnostics in the returned list.
#' @param scale_Z Logical. If `TRUE` (default when `binary_Z = FALSE`), standardizes
#'   continuous Z columns across features.
#'
#' @return A list with elements:
#'   - `X` (n x p), `Y` (length n)
#'   - `Z` (p x q) including intercept
#'   - `theta` (length q)
#'   - `selection` (length p), `s_prob` (length p)
#'   - `true_beta` (length p), `mu_true` (length n)
#'   - `noise_sd_0` (numeric), `true_signal_percent` (numeric)
#'   - `diagnostics` (optional)
#'
#' @examples
#' # Minimal example (independent features)
#' dat <- Data_generation(
#'   n = 100, p = 500, re_sd = "Independent",
#'   L = NULL, cov_matrix = NULL,
#'   q = 2, mu_beta_true = 1,
#'   theta_intercept = -2, theta_side_info = 1,
#'   SNR = 2,
#'   z_mean = 0.2, z_variance = 1,
#'   seed_val = 1,
#'   binary_Z = TRUE,
#'   k = 1, c = 0, v = 1
#' )
Data_generation <- function(
  n,
  p,
  re_sd,
  L = NULL,
  cov_matrix = NULL,
  q,
  mu_beta_true,
  theta_intercept,
  theta_side_info,
  SNR,
  z_mean,
  z_variance,
  seed_val,
  binary_Z,
  k,
  c,
  v,
  verbose = FALSE,
  return_diagnostics = TRUE
) {
  re_sd <- match.arg(re_sd, choices = c("Identical", "Independent", "Matern"))

  if (!is.numeric(n) || length(n) != 1 || n <= 0) stop("n must be a positive integer.")
  if (!is.numeric(p) || length(p) != 1 || p <= 0) stop("p must be a positive integer.")
  n <- as.integer(n)
  p <- as.integer(p)

  if (!is.numeric(q) || length(q) != 1 || q < 1) stop("q must be an integer >= 1.")
  q <- as.integer(q)
  if (!is.numeric(SNR) || length(SNR) != 1 || SNR <= 0) stop("SNR must be a single number > 0.")
  if (!is.numeric(z_variance) || length(z_variance) != 1 || z_variance <= 0) stop("z_variance must be > 0.")

  if (!is.null(seed_val)) {
    set.seed(seed_val)
    if (isTRUE(verbose)) message("Data_generation(): seed_val = ", seed_val)
  }

  # --- Legacy X and Z generation (matches original file) -------------------
  # Note: In the original implementation, Z is generated differently across modes:
  # - Independent: i.i.d. binary or normal with mean/variance
  # - Identical: X is correlated via L; Z is i.i.d. Bernoulli(z_mean)
  # - Matern: X is correlated via L; Z is generated from exactly 2 correlated columns

  if (re_sd %in% c("Identical", "Matern")) {
    L <- .require_L_for_correlated(L = L, cov_matrix = cov_matrix)
  }

  if (re_sd == "Identical") {
    total_dim <- n + q
    z_samples <- matrix(rnorm(total_dim * p), nrow = p)
    mvn_samples <- t(L %*% z_samples)
    X <- scale(mvn_samples[1:n, , drop = FALSE], center = TRUE, scale = TRUE)

    if (q > 1L) {
      Z_raw <- matrix(rbinom(p * (q - 1L), size = 1, prob = z_mean), nrow = p, ncol = q - 1L)
      if (isTRUE(binary_Z)) {
        Z_raw <- ifelse(Z_raw > 0, 1, 0)
      }
    } else {
      Z_raw <- matrix(numeric(0), nrow = p, ncol = 0)
    }
  } else if (re_sd == "Independent") {
    X <- scale(matrix(rnorm(n * p), nrow = n, ncol = p), center = TRUE, scale = TRUE)

    if (q > 1L) {
      if (isTRUE(binary_Z)) {
        Z_raw <- matrix(rbinom(p * (q - 1L), size = 1, prob = z_mean), nrow = p, ncol = q - 1L)
      } else {
        Z_raw <- matrix(rnorm(p * (q - 1L), mean = z_mean, sd = sqrt(z_variance)), nrow = p, ncol = q - 1L)
      }
    } else {
      Z_raw <- matrix(numeric(0), nrow = p, ncol = 0)
    }
  } else if (re_sd == "Matern") {
    # Legacy behavior uses exactly 2 side-information columns under Matern.
    if (q != 3L) {
      stop("Legacy re_sd='Matern' expects q = 3 (intercept + 2 side-info columns). Got q = ", q, ".")
    }
    z_samples_forX <- matrix(rnorm(n * p), nrow = p)
    x_mvn_samples <- t(L %*% z_samples_forX)
    X <- scale(x_mvn_samples[1:n, , drop = FALSE], center = TRUE, scale = TRUE)

    z_samples_forZ <- matrix(rnorm(2 * p), nrow = p)
    z_mvn_samples <- t(L %*% z_samples_forZ)
    Z_raw <- scale(t(z_mvn_samples), center = TRUE, scale = TRUE)
    if (isTRUE(binary_Z)) {
      Z_raw <- ifelse(Z_raw > 0, 1, 0)
    }
  }

  # Legacy construction (intercept + columns of Z_raw)
  Z <- model.matrix(~Z_raw)

  # --- True beta + response -------------------------------------------------
  true_beta <- runif(p, min = 0, max = 2 * mu_beta_true)
  theta <- c(theta_intercept, rep(theta_side_info, max(q - 1L, 0L)))

  # Match the original computation order and shapes
  theta_Z_prod <- .as_numeric_vector(theta %*% t(Z))
  s_prob <- generalized_logistic(theta_Z_prod, k = k, c = c, v = v)

  selection <- rbinom(p, size = 1, prob = s_prob)
  true_beta[selection == 0] <- 0
  true_signal_precent <- sum(true_beta != 0) / p * 100

  mu_true <- .as_numeric_vector(X %*% true_beta)
  noise_sd_0 <- stats::sd(mu_true) / SNR
  Y <- .as_numeric_vector(scale(mu_true + rnorm(n, mean = 0, sd = noise_sd_0), center = TRUE, scale = FALSE))

  diagnostics <- NULL
  if (isTRUE(return_diagnostics) || isTRUE(verbose)) {
    confusion_table_g <- matrix(0, nrow = 2, ncol = 2)
    colnames(confusion_table_g) <- c("True Signal", "False Signal")
    rownames(confusion_table_g) <- c("Est. Signal", "Est. non-Signal")

    for (i in seq_len(p)) {
      row_index <- ifelse(s_prob[i] >= 0.5, 1, 2)
      col_index <- ifelse(selection[i] == 1, 1, 2)
      confusion_table_g[row_index, col_index] <- confusion_table_g[row_index, col_index] + 1
    }

    diagnostics <- list(
      confusion_table_g = confusion_table_g,
      true_signal_precent = true_signal_precent,
      seed_val = seed_val
    )

    if (isTRUE(verbose)) {
      message("Percent of true signals (non-zero coefficients): ", sprintf("%.2f", true_signal_precent), "%")
      print(confusion_table_g)
    }
  }

  return(list(
    X = X,
    Y = Y,
    Z = Z,
    theta = theta,
    q = q,
    p = p,
    n = n,
    selection = selection,
    s_prob = .as_numeric_vector(s_prob),
    true_beta = true_beta,
    mu_true = mu_true,
    noise_sd_0 = noise_sd_0,
    true_signal_precent = true_signal_precent,
    true_signal_percent = true_signal_precent,
    diagnostics = diagnostics
  ))
}


#' Convenience wrapper: generate one dataset from a scenario table
#'
#' @description
#' Extracts simulation settings for a single row/entry of `table_data` and calls
#' [Data_generation()].
#'
#' `table_data` can be either:
#' - a `data.frame` with columns like `n`, `p`, `re_sd`, `q`, `mu_beta_true`, `Z_binary`,
#'   optionally `z_mean`, `z_variance`; or
#' - a list that stores vectors under names like `n_list`, `p_list`, `re_sd_list`, etc.
#'
#' @param table_data A `data.frame` or list containing scenario settings.
#' @param table_data_index Integer. Which row/entry to use.
#' @param L,cov_matrix See [Data_generation()]. Required for correlated settings.
#' @param theta_intercept,theta_side_info,SNR,seed_val,k,c,v See [Data_generation()].
#' @param z_mean,z_variance Optional overrides. If `NULL`, will try to read from
#'   `table_data`; if still missing, falls back to defaults with a warning.
#' @param verbose Logical. Passed to [Data_generation()].
#'
#' @return The list returned by [Data_generation()].
generate_data <- function(
  table_data,
  table_data_index,
  L = NULL,
  cov_matrix = NULL,
  theta_intercept,
  theta_side_info,
  SNR,
  seed_val,
  k,
  c,
  v,
  z_mean = NULL,
  z_variance = NULL,
  verbose = FALSE
) {
  idx <- as.integer(table_data_index)

  .get_at <- function(primary, fallback = NULL) {
    if (!is.null(primary)) return(primary)
    fallback
  }

  .pull <- function(name, alt = character(0)) {
    # Returns the vector for name/alt from list or data.frame.
    if (is.data.frame(table_data)) {
      for (nm in c(name, alt)) {
        if (nm %in% names(table_data)) return(table_data[[nm]])
      }
      return(NULL)
    }
    if (is.list(table_data)) {
      for (nm in c(name, alt)) {
        if (!is.null(table_data[[nm]])) return(table_data[[nm]])
      }
      return(NULL)
    }
    stop("table_data must be a data.frame or a list.")
  }

  n_vec <- .pull("n", alt = "n_list")
  p_vec <- .pull("p", alt = "p_list")
  re_sd_vec <- .pull("re_sd", alt = "re_sd_list")
  q_vec <- .pull("q", alt = "q_list")
  mu_beta_vec <- .pull("mu_beta_true", alt = "mu_beta_true_list")
  binaryZ_vec <- .pull("Z_binary", alt = "Z_binary_list")

  if (is.null(n_vec) || is.null(p_vec) || is.null(re_sd_vec) || is.null(q_vec) || is.null(mu_beta_vec) || is.null(binaryZ_vec)) {
    stop("table_data is missing required fields. Expected (n, p, re_sd, q, mu_beta_true, Z_binary) or *_list variants.")
  }

  n <- n_vec[idx]
  p <- p_vec[idx]
  re_sd <- re_sd_vec[idx]
  q <- q_vec[idx]
  mu_beta_true <- mu_beta_vec[idx]
  binary_Z <- binaryZ_vec[idx]

  # Try to obtain z_mean / z_variance if not supplied.
  if (is.null(z_mean)) {
    zmean_vec <- .pull("z_mean", alt = "z_mean_list")
    if (!is.null(zmean_vec)) {
      z_mean <- zmean_vec[idx]
    } else {
      warning("generate_data(): z_mean not provided and not found in table_data; using default z_mean = 0.")
      z_mean <- 0
    }
  }
  if (is.null(z_variance)) {
    zvar_vec <- .pull("z_variance", alt = "z_variance_list")
    if (!is.null(zvar_vec)) {
      z_variance <- zvar_vec[idx]
    } else {
      warning("generate_data(): z_variance not provided and not found in table_data; using default z_variance = 1.")
      z_variance <- 1
    }
  }

  # Generate the dataset
  Data_set <- Data_generation(
    n = n,
    p = p,
    re_sd = re_sd,
    L = L,
    cov_matrix = cov_matrix,
    q = q,
    mu_beta_true = mu_beta_true,
    theta_intercept = theta_intercept,
    theta_side_info = theta_side_info,
    SNR = SNR,
    z_mean = z_mean,
    z_variance = z_variance,
    seed_val = seed_val,
    binary_Z = binary_Z,
    k = k,
    c = c,
    v = v,
    verbose = verbose
  )

  return(Data_set)
}

